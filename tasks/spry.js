/* global console */
/* global require */
/* global module */

module.exports = function(grunt) {
    'use strict';
    //create the main function
    function Spry() {
        // require dependencies
        var im = require('easyimage');
        var kiwi = require('kiwi');
        var fs = require('fs');
        var exec = require('child_process').exec;

        // get the options provided in the gruntfile
        var options = this.options();

        // set the required variables for the sprites
        var retina, simple;
        var retina_sprite, simple_sprite;
        var css_retina = [];
        var css_simple = [];
        var css = [];
        var css_info = 0;

        var simple_pos = {'x':0, 'y':0};
        var retina_pos = {'x':0, 'y':0};

        var output;

        // this script has many async operations and we need to
        // tell this to grunt
        this.async();

         if (!options.format || !options.cssOut) {
            return grunt.fatal('format option and output file must be provided');
         }


        var message = '/* file generated by spry! */\n';
        fs.writeFile(options.cssOut, message, function(err) {
            if(err) {
                grunt.log.error(err);
            }
        });


         for (var i = 0; i < this.files.length; i++) {
            if (this.files[i].retina) {
               retina = this.files[i];
            } else {
               simple = this.files[i];
            }
        }

        retina_sprite = retina.dest;
        simple_sprite = simple.dest;

        function split(arr) {
            for (var i=0; i<arr.length; i++) {
                arr[i] = arr[i].split('/').pop();
            }
            return arr;
        }

        function path(file) {
            var file_path = file.split('/').slice(0, -1).join('/');
            return file_path;
        }

        function intersection(retina, simple) {
            if (simple.length) {
                var inter = [];
                var j = 0;
                var simple_path = path(simple[0]);
                var retina_split = split(retina);
                var simple_split = split(simple);
                for (var i=0; i < retina.length; ++i) {
                    if (simple_split.indexOf(retina_split[i]) !== -1) {
                        inter[j++] = retina_split[i];
                    }
                }
                if (inter) {
                    return [inter, simple_path];
                }
            } else {
                return false;
            }
        }

        var simple_override = intersection(retina.src, simple.src);

        var resize =  function(file, callback) {
            var cmd = 'convert ';
            var input = file;

            var output =  path(simple.orig.src[0]) + '/' + file.split('/').pop();

            function puts(error) {
                if (error) {
                    grunt.log.error(error);
                }
            }

            cmd += input;
            cmd += ' -resize 50% ';
            cmd += output;
            exec(cmd, puts);
            callback();
        };

        if (simple_override) {
            for (i=0; i < retina.src.length; i++) {
                if (simple_override[0].indexOf(retina.src[i]) === -1 ) {
                    grunt.log.write('resized:' + retina.src[i]);
                }
            }

        } else {
            // we will resize all the retina images and put them into the simple images dir
            grunt.util.async.map(retina.src, resize, function(err, info) {
                grunt.log.write('all images resized');
            });
        }

        var imageInfo = function(file, callback) {
            im.info(file, function(err, info, stderr) {
                callback(stderr, info);
            });
        };

        var sprite =  function(files,callback) {
            var cmd = 'montage -mode concatenate -tile x1 -background transparent';
            var output = files.dest;
            var input = files.orig.src;

            function puts(error) {
                if (error) {
                    grunt.log.error(error);
                }
            }

            cmd += ' ' + input + ' '+ output;
            cmd = cmd.replace(/,+/g,' ');
            exec(cmd, puts);
            callback();
        };

        grunt.util.async.map([simple, retina ], sprite, function(){
            grunt.log.write('the sprites are ready!');
        });

        var retina_files = [];
        var retina_path = path(retina.orig.src[0]);
        for (i=0; i < retina.src.length; i++) {
            retina_files.push(retina_path+'/'+retina.src[i]);
        }

        grunt.util.async.map(retina_files, imageInfo, function(err, info) {
            css_retina.push(info);
            css_info += 1;
            if (css_info === 2) {
                createCss();
            }
        });

        function render(css) {
            simple_pos.x += parseInt(css[1].width, 10);
            simple_pos.y += parseInt(css[1].height, 10);

            retina_pos.x += parseInt(css[0].width, 10);
            retina_pos.y += parseInt(css[0].height, 10);

            var current_simple_pos = {};
            var current_retina_pos = {};

            current_simple_pos.x = simple_pos.x;
            current_simple_pos.y = simple_pos.y;
            current_retina_pos.x = retina_pos.x;
            current_retina_pos.y = retina_pos.y;

            var simple_sprite_path = simple_sprite.split('/');
            var retina_sprite_path = retina_sprite.split('/');
            simple_sprite_path = simple_sprite_path[simple_sprite_path.length - 1];
            retina_sprite_path = retina_sprite_path[retina_sprite_path.length - 1];


            var template = new kiwi.Template().loadAndRender(__dirname + '/../templates/less.kiwi',
            {   'name': css[0].name.split('.')[0],
                'simple_sprite_path': simple_sprite_path,
                'retina_sprite_path': retina_sprite_path,
                'simple_pos': current_simple_pos,
                'retina_pos': current_retina_pos,
                'retina': css[0],
                'simple': css[1],
                'retina_width': retina_width
            },
            function onRendered(err, rendered) {
                output += (String(rendered));
                fs.appendFile(options.cssOut, rendered, function(err) {
                    if(err) {
                        grunt.log.error(err);
                    }
                });
            });
        }

        var retina_width = 0;
        function createCss() {
            // css Array contains the info of the pairs of each icon [retina, simple]
            for (i = 0; i < css_retina[0].length; i++) {
                css.push([css_retina[0][i],css_simple[0][i]]);
                retina_width += parseInt(css_retina[0][i].width, 10);
            }

            grunt.util.async.map(css, render, function(err) {
                if (err) {
                    grunt.log.error('Could not write output. \n' + err);
                }
                grunt.log.write('generating template...');
            });
        }

        var simple_files = [];
        var simple_path = path(simple.orig.src[0]);
        for (i=0; i < simple.src.length; i++) {
            simple_files.push(simple_path+'/'+simple.src[i]);
        }

        grunt.util.async.map(simple_files, imageInfo, function(err, info) {
            css_simple.push(info);
            css_info += 1;
            if (css_info === 2) {
                createCss();
            }
        });
    }

    // Export the above code
    grunt.registerMultiTask('spry', 'Generate sprites', Spry);
};